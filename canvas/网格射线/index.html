<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas射线</title>
  <style>
    html, body, canvas {
      width: 100%;
      height: 100%;
      overflow: hidden;
      /* content-zooming: none; */
      padding:0;
      margin:0;
    }
  </style>
</head>
<body>
  <canvas></canvas>

  <script>
    let af
    const gridSize = 30
    const canvas = document.querySelector("canvas")
    const ctx = canvas.getContext("2d")
    const options = [
      {
        length: 5,
        offset: 5,
        start: { x: 1, y: 1 },
        end: { x: 21, y: 22 },
        path: [
          { x: 2, y: 3 },
          { x: 4, y: 5},
          { x: 6, y: 7},
          { x: 8, y: 9},
          { x: 10, y: 11},
          { x: 12, y: 13},
          { x: 24, y: 15},
          { x: 16, y: 17},
          { x: 18, y: 19},
          { x: 20, y: 21 }
        ]
      }
    ]

    // 获取两点连线与x轴的夹角
    const angle = (a, b) => {
      var dx = b.x - a.x
      var dy = b.y - a.y
      var dis = Math.sqrt(dx * dx + dy * dy);
      var rota = dis > 0 ? Math.round(Math.asin(dy / dis) / Math.PI * 180) : 0
      // rota范围（-90，90）当b点在a点左边时，必要另处理
      if (b.x < a.x) {
          rota = 180 - rota
      }
      return rota
    }

    // 渲染背景
    const renderBg = () => {
      ctx.fillStyle = 'hsl(261,43%,7%)'
      ctx.fillRect(0, 0, canvas.width, canvas.height)
    }

    // 创建网格线条
    const createGridlines = () => {
      const { width, height } = canvas
      const xLines = new Array(Math.floor(width / gridSize)).fill(0).map((item, index) => ({
        start: [ gridSize * (index + 1), 0 ],
        end: [ gridSize * (index + 1), height - 0.5 ]
      }))
      const yLines = new Array(Math.floor(height / gridSize)).fill(0).map((item, index) => ({
        start: [ 0 ,gridSize * (index + 1) ],
        end: [ width - 0.5, gridSize * (index + 1) ]
      }))
      return [ ...xLines, ...yLines ]
    }

    // 渲染网格线条
    const renderGrid = () => {
      const lines = createGridlines()
      lines.forEach(item => {
        ctx.beginPath()
        ctx.moveTo(...item.start)
        ctx.lineTo(...item.end)
        ctx.strokeStyle = '#333'
        ctx.stroke()
      })
    }

    // 补齐路径
    const makePath = path => {
      const _path = []
      for (let i = 0; path[i]; i++) {
        const cur = path[i]
        const next = path[i + 1]
        _path.push({ ...cur })
        // 两点连线和边缘不平行
        if (next && cur.x !== next.x && cur.y !== next.y) {
          const a = angle(cur, next)
          // if (a > 0 && a < 90) _.path.push({  })}
          if (next.x > cur.x) {
            _path.push({ x: cur.x, y: next.y })
          } else {
            _path.push({ x: next.x, y: cur.y })
          }
        }
      }
      return _path
    }

    // 两点间距离
    const getTwoPointDistance = (point1, point2) => {
      const value1 = Math.pow(point1.x - point2.x, 2)
      const value2 = Math.pow(point1.y - point2.y, 2)
      return Math.floor(Math.sqrt(value1 + value2))
    }

    // 根据坐标获取下一个转折点
    const getNextTurningPointIndex = ({ x, y }, paths) => {
      const last = paths[paths.length - 1] || {}
      const lastX = last.x * gridSize
      const lastY = last.y * gridSize
      
      for (let i = 0; paths[i]; i++) {
        const cur = paths[i] || {}
        const next = paths[i + 1] || {}
        const curX = cur.x * gridSize
        const curY = cur.y * gridSize
        const nextX = next.x * gridSize
        const nextY = next.y * gridSize

        // 如果为最后一个点，则返回0
        if (x === lastX && y === lastY) return paths.length - 1
        // 三点共线，判断point是否在当前两点线段中
        if ((curY - y) * (nextX - curX) === (nextY - curY) * (curX - x)) {
          return i + 1
        }
      }
      // 如果未找到，返回-1
      return -1
    }

    // 获取经过的path前后索引
    const getPathRange = ({ path, current: { head, tail } }) => {
      const start = getNextTurningPointIndex(tail, path)
      const end = getNextTurningPointIndex(head, path)
      return [ start, end - 1 ]
    }

    // 创建激光
    const createLasers = () => {
      const lasers = []
      options.forEach(({ start, end, path, offset, length }) => {
        const temp = {
          offset,
          length,
          start: { ...start },
          end: { ...end },
          path: makePath([ start, ...path, end ])
        }
        temp['current'] = {
          tail: { x: start.x * gridSize, y: start.y * gridSize, index: 0 },
          head: getNextPoint({x: start.x * gridSize, y: start.y * gridSize, index: 0}, length * gridSize, temp.path)
        }
        lasers.push(temp)
      })
      console.log(lasers)
      return lasers
    }

    // 渲染单个激光
    const renderLaser = ({ path, current: { head, tail } }) => {
      const { offsetX, offsetY } = canvas
      ctx.strokeStyle = 'red'
      ctx.beginPath()
      ctx.moveTo(tail.x, tail.y)
      const range = [ tail.index + 1, head.index ]
      // const range = getPathRange({ path, current: { tail, head } })
      // console.log(range)
      if (range[0] || range[1] || range[0] !== range[1]) {
        for (let i = range[0]; i <= range[1]; i++) {
          ctx.lineTo(path[i].x * gridSize, path[i].y * gridSize)
        }
      }
      ctx.lineTo(head.x, head.y)
      ctx.stroke()
    }

    // 渲染激光
    const renderLasers = lasers => {
      renderBg()
      renderGrid()
      lasers.forEach(item => {
        renderLaser(item)
        updateLaser(item)
      })
      af = requestAnimationFrame(() => { renderLasers(lasers) })
    }

    // 根据坐标移动距离，定位轨迹中的位置
    const getNextPoint = (point, offset, paths) => {
      const { x: lastX = x * gridSize, y: lastY = y * gridSize } = paths[paths.length - 1]
      if (point.x === lastX && point.y === lastY && point.index === paths.length - 1) return { ...point }
      // debugger
      let count = offset
      // 下一个转折点
      // let next = getNextTurningPointIndex(point, paths)
      let next = point.index + 1
      if (!paths[next]) return { ...point }
      // console.log({next})
      // 当前出发点
      let beginPoint = { ...point }
      // 下一个转折点坐标
      let turningPoint = { x: paths[next].x * gridSize, y: paths[next].y * gridSize }
      while (count > 0) {
        // 当前点和下一个转折点的距离
        const distance = getTwoPointDistance(beginPoint, turningPoint)
        count -= distance
        // 大于offset
        if (count > 0) {
          // 设置下一段起始点
          next++
          if (paths[next]) {
            beginPoint = { ...turningPoint }
            turningPoint = { x: paths[next].x * gridSize, y: paths[next].y * gridSize }
          } else {
            return { ...beginPoint, index: next - 1 }
          }
        }
        // 小于offset
        if (count < 0) {
          const a = angle(beginPoint, turningPoint)
          const _count = count + distance
          if (a === 0) return { x: beginPoint.x += _count, y: beginPoint.y, index: next - 1 }
          if (a === 90) return { x: beginPoint.x, y: beginPoint.y += _count, index: next - 1 }
          if (a === 180) return { x: beginPoint.x -= _count, y: beginPoint.y, index: next - 1 }
          if (a === 270) return { x: beginPoint.x, y: beginPoint.y -= _count, index: next - 1 }
        }
        // 等于offset
        if (count === 0) {
          return { ...turningPoint, index: next - 1 }
        }
      }
    }

    // 更新激光
    const updateLaser = laser => {
      const { offset, current: { head, tail }, path } = laser
      const { x: lastX = x * gridSize, y: lastY = y * gridSize } = path[path.length - 1]

      // 如果当前坐标为最后一点
      if (head.index === tail.index && tail.index === path.length - 1) {
        console.log('当前运动完毕')
        cancelAnimationFrame(af)
        return
        // init()
      }

      laser.current.head = { ...getNextPoint(head, offset, path) }
      laser.current.tail = { ...getNextPoint(tail, offset, path) }
    }

    const init = () => {
      cancelAnimationFrame(af)
      canvas.width = window.innerWidth
      canvas.height = window.innerHeight
      // renderGrid()
      renderLasers(createLasers())
    };
    window.onresize = init
    init()
  </script>
</body>
</html>